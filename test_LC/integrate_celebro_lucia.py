#!/usr/bin/env python3
"""
Integraci√≥n @celebro con LucIA
Versi√≥n: 0.6.0
Conecta el sistema @celebro con LucIA para interpretaci√≥n de respuestas
"""

import asyncio
import json
import logging
from datetime import datetime
from typing import Dict, Any, List, Optional

# Importar m√≥dulos de LucIA
from main import LucIACore
from celebro import CelebroCore

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('Celebro_LucIA_Integration')

class CelebroLucIAIntegration:
    """Integraci√≥n entre @celebro y LucIA"""
    
    def __init__(self):
        self.lucia = LucIACore()
        self.celebro = CelebroCore()
        self.integration_active = False
        self.response_cache = {}
        
        logger.info("Integraci√≥n @celebro-LucIA inicializada")
    
    async def initialize(self):
        """Inicializa la integraci√≥n"""
        try:
            # Inicializar LucIA
            print("üîÑ Inicializando LucIA...")
            await self.lucia.initialize_modules()
            
            # Inicializar @celebro
            print("üîÑ Inicializando @celebro...")
            await self.celebro.initialize()
            
            self.integration_active = True
            print("‚úÖ Integraci√≥n @celebro-LucIA activa")
            return True
            
        except Exception as e:
            logger.error(f"Error inicializando integraci√≥n: {e}")
            return False
    
    async def process_with_celebro(self, user_input: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Procesa entrada del usuario usando LucIA y @celebro
        
        Args:
            user_input: Entrada del usuario
            context: Contexto adicional
        
        Returns:
            Resultado del procesamiento integrado
        """
        try:
            if not self.integration_active:
                return {"error": "Integraci√≥n no activa"}
            
            # 1. Procesar con LucIA
            print("üß† Procesando con LucIA...")
            lucia_result = await self.lucia.process_input(user_input, context or {})
            
            # 2. Simular respuestas de IAs externas (en un caso real, estas vendr√≠an de APIs)
            external_responses = await self._simulate_external_ai_responses(user_input, lucia_result)
            
            # 3. Procesar respuestas externas con @celebro
            celebro_results = []
            for response_data in external_responses:
                print(f"üîç Procesando respuesta de {response_data['source_ai']} con @celebro...")
                celebro_result = await self.celebro.process_ai_response(
                    response=response_data['response'],
                    source_ai=response_data['source_ai'],
                    user_context=context,
                    session_id=f"lucia_integration_{int(datetime.now().timestamp())}"
                )
                celebro_results.append(celebro_result)
            
            # 4. Consultar @celebro para respuesta final
            print("üß† Consultando @celebro para respuesta final...")
            final_query = f"Bas√°ndome en la consulta '{user_input}' y el contexto de LucIA, proporciona una respuesta integral"
            celebro_response = await self.celebro.query_celebro(
                query=final_query,
                context=context,
                session_id=f"final_query_{int(datetime.now().timestamp())}"
            )
            
            # 5. Combinar resultados
            integrated_result = {
                "user_input": user_input,
                "lucia_processing": {
                    "status": "completed",
                    "result": str(lucia_result)
                },
                "external_ai_responses": len(external_responses),
                "celebro_processing": {
                    "responses_processed": len(celebro_results),
                    "final_response": celebro_response.get('response', 'No disponible')
                },
                "integrated_response": celebro_response.get('response', 'No disponible'),
                "knowledge_sources": celebro_response.get('knowledge_sources', 0),
                "timestamp": datetime.now().isoformat()
            }
            
            return integrated_result
            
        except Exception as e:
            logger.error(f"Error en procesamiento integrado: {e}")
            return {
                "error": str(e),
                "user_input": user_input,
                "timestamp": datetime.now().isoformat()
            }
    
    async def _simulate_external_ai_responses(self, user_input: str, lucia_result: Any) -> List[Dict[str, Any]]:
        """Simula respuestas de IAs externas"""
        try:
            # Simular respuestas de diferentes IAs basadas en la entrada del usuario
            responses = []
            
            # Respuesta t√©cnica (GPT-4)
            if any(word in user_input.lower() for word in ["c√≥digo", "programaci√≥n", "algoritmo", "t√©cnico"]):
                responses.append({
                    "response": "Desde una perspectiva t√©cnica, la programaci√≥n requiere entender algoritmos, estructuras de datos y patrones de dise√±o. Es importante seguir buenas pr√°cticas y escribir c√≥digo limpio y mantenible.",
                    "source_ai": "GPT-4",
                    "confidence": 0.9
                })
            
            # Respuesta creativa (Claude-3)
            if any(word in user_input.lower() for word in ["creativo", "dise√±o", "arte", "innovaci√≥n"]):
                responses.append({
                    "response": "La creatividad en tecnolog√≠a se trata de pensar fuera de la caja, combinar ideas de manera inesperada y crear soluciones que no solo funcionen, sino que inspiren y emocionen a los usuarios.",
                    "source_ai": "Claude-3",
                    "confidence": 0.85
                })
            
            # Respuesta anal√≠tica (Gemini-Pro)
            if any(word in user_input.lower() for word in ["an√°lisis", "datos", "estad√≠stica", "investigaci√≥n"]):
                responses.append({
                    "response": "El an√°lisis de datos requiere un enfoque sistem√°tico: recopilaci√≥n, limpieza, exploraci√≥n, modelado y validaci√≥n. Es crucial entender el contexto del negocio para interpretar correctamente los resultados.",
                    "source_ai": "Gemini-Pro",
                    "confidence": 0.88
                })
            
            # Respuesta filos√≥fica (Claude-3)
            if any(word in user_input.lower() for word in ["√©tica", "moral", "filosof√≠a", "valores"]):
                responses.append({
                    "response": "La √©tica en tecnolog√≠a no es solo una consideraci√≥n posterior, sino un principio fundamental. Debemos preguntarnos constantemente sobre el impacto de nuestras creaciones en la humanidad y el planeta.",
                    "source_ai": "Claude-3",
                    "confidence": 0.92
                })
            
            # Respuesta pr√°ctica (GPT-4)
            if any(word in user_input.lower() for word in ["c√≥mo", "pasos", "procedimiento", "implementar"]):
                responses.append({
                    "response": "Para implementar una soluci√≥n efectiva, primero define claramente el problema, luego investiga las mejores pr√°cticas, crea un plan paso a paso, y finalmente itera bas√°ndote en el feedback recibido.",
                    "source_ai": "GPT-4",
                    "confidence": 0.87
                })
            
            # Si no hay respuestas espec√≠ficas, generar una respuesta general
            if not responses:
                responses.append({
                    "response": "Bas√°ndome en mi conocimiento, puedo ayudarte con una variedad de temas. ¬øPodr√≠as ser m√°s espec√≠fico sobre lo que te gustar√≠a saber?",
                    "source_ai": "General_AI",
                    "confidence": 0.7
                })
            
            return responses
            
        except Exception as e:
            logger.error(f"Error simulando respuestas externas: {e}")
            return []
    
    async def get_integration_stats(self) -> Dict[str, Any]:
        """Obtiene estad√≠sticas de la integraci√≥n"""
        try:
            # Estad√≠sticas de LucIA
            lucia_stats = {
                "modules_initialized": len(self.lucia.modules) if hasattr(self.lucia, 'modules') else 0,
                "status": "active" if self.lucia else "inactive"
            }
            
            # Estad√≠sticas de @celebro
            celebro_stats = await self.celebro.get_celebro_stats()
            
            # Estad√≠sticas de integraci√≥n
            integration_stats = {
                "integration_active": self.integration_active,
                "responses_cached": len(self.response_cache),
                "last_activity": datetime.now().isoformat()
            }
            
            return {
                "lucia": lucia_stats,
                "celebro": celebro_stats,
                "integration": integration_stats,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Error obteniendo estad√≠sticas: {e}")
            return {"error": str(e)}
    
    async def start_interactive_session(self):
        """Inicia una sesi√≥n interactiva integrada"""
        try:
            print("=" * 80)
            print("üß†üí° LucIA + @celebro - Sesi√≥n Interactiva Integrada")
            print("=" * 80)
            print("üí° Escribe 'quit' para salir")
            print("üí° Escribe 'stats' para ver estad√≠sticas")
            print("üí° Escribe 'help' para ver comandos disponibles")
            print()
            
            while True:
                try:
                    user_input = input("T√∫: ").strip()
                    
                    if user_input.lower() in ['quit', 'exit', 'salir']:
                        print("LucIA + @celebro: ¬°Hasta luego! Ha sido un placer ayudarte. üëã")
                        break
                    
                    elif user_input.lower() == 'stats':
                        stats = await self.get_integration_stats()
                        print(f"\nüìä Estad√≠sticas de la integraci√≥n:")
                        print(f"   LucIA: {stats['lucia']['modules_initialized']} m√≥dulos activos")
                        print(f"   @celebro: {stats['celebro']['sessions']['total_responses_processed']} respuestas procesadas")
                        print(f"   Integraci√≥n: {'Activa' if stats['integration']['integration_active'] else 'Inactiva'}")
                        continue
                    
                    elif user_input.lower() == 'help':
                        print("\nüîß Comandos disponibles:")
                        print("   - Preg√∫ntame sobre cualquier tema")
                        print("   - 'stats' - Ver estad√≠sticas del sistema")
                        print("   - 'quit' - Salir de la sesi√≥n")
                        print("   - LucIA procesar√° tu entrada y @celebro la enriquecer√° con conocimiento de m√∫ltiples IAs")
                        continue
                    
                    elif not user_input:
                        continue
                    
                    # Procesar con integraci√≥n
                    print("LucIA + @celebro: Procesando...")
                    result = await self.process_with_celebro(user_input)
                    
                    if 'error' in result:
                        print(f"‚ùå Error: {result['error']}")
                    else:
                        print(f"\nüß†üí° LucIA + @celebro responde:")
                        print(f"{result['integrated_response']}")
                        print(f"\nüìö Basado en {result['knowledge_sources']} fuentes de conocimiento")
                        print(f"üîç Procesadas {result['external_ai_responses']} respuestas de IAs externas")
                        print(f"‚öôÔ∏è @celebro proces√≥ {result['celebro_processing']['responses_processed']} respuestas")
                
                except KeyboardInterrupt:
                    print("\nLucIA + @celebro: ¬°Hasta luego! üëã")
                    break
                except Exception as e:
                    print(f"‚ùå Error: {e}")
        
        except Exception as e:
            logger.error(f"Error en sesi√≥n interactiva: {e}")
            print(f"‚ùå Error en sesi√≥n interactiva: {e}")

async def main():
    """Funci√≥n principal"""
    integration = CelebroLucIAIntegration()
    
    # Inicializar integraci√≥n
    if not await integration.initialize():
        print("‚ùå Error inicializando integraci√≥n")
        return
    
    # Iniciar sesi√≥n interactiva
    await integration.start_interactive_session()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã ¬°Hasta luego!")
    except Exception as e:
        print(f"‚ùå Error: {e}")
